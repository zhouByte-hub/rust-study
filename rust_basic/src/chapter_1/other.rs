// Rust中声明变量时也可以不声明类型，Rust 会根据变量的使用来确定其类型。
// 数字中的所有下划线均可忽略，它们只是为了方便辨识。因此，1_000 可以写为 1000（或 10_00），而 123_i64 可以写为 123i64。
// Rust 的变量在默认情况下是不可变的，要使变量可变就需要在前面加上 mut。
// 使用下划线开头可以忽略未使用的变量。

// 常量不允许使用 mut。常量不仅仅默认不可变，而且自始至终不可变，因为常量在编译完成后，已经确定它的值。
// 常量使用 const 关键字而不是 let 关键字来声明，并且值的类型必须标注。
// Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的。

// 变量的解构
pub fn test_1() {
    // let 表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容
    let (_a, _b) = (true, false);
    let (_d, mut _f) = (true, false);

    // 我们可以在赋值语句的左式中使用元组、切片和结构体模式了。
    let [_a, .., _b, _] = [1, 2, 3, 4, 5];
}

// 对于移位运算，Rust 会检查它是否超出该整型的位数范围，如果超出，则会报错 overflow。
pub fn position_operation() {
    let a = 5;
    let b = 6;

    // 相同位置均为1时则为1，否则为0
    println!("{}", a & b);

    // 相同位置只要有1时则为1，否则为0
    println!("{}", a | b);

    // 相同位置不相同则为1，相同则为0
    println!("{}", a ^ b);

    // 把位中的0和1相互取反，即0置为1，1置为0
    println!("{}", !a);

    // 所有位向左移动指定位数，右位补0
    println!("{}", a << b);

    // 所有位向右移动指定位数，带符号移动（正数补0，负数补1）
    println!("{}", a >> b);
}

// 序列
pub fn test() {
    // Rust 提供了一个非常简洁的方式，用来生成连续的数值
    let a = [1..=5];
    println!("{:?}", a);

    for item in 1..=100 {
        println!("{}", item);
    }
}
