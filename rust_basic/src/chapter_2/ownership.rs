/** 所有权
 *  所有的程序都必须和计算机内存打交道，如何从内存中申请空间来存放程序的运行内容，如何在不需要的时候释放这些空间，成了重中之重，也是所有编程语言设计的难点之一。在计算机语言不断演变过程中，出现了三种流派：
 *      1、 垃圾回收机制(GC)，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
 *      2、手动管理内存的分配和释放, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
 *      3、通过所有权来管理内存，编译器在编译时会根据一系列规则进行检查
 * 其中 Rust 选择了第三种，最妙的是，这种检查只发生在编译期，因此对于程序运行期，不会有任何性能上的损失。
 */

 // 栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。
 /**
  * 当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的指针，该过程被称为在堆上分配内存，有时简称为 “分配”(allocating)。
  * 接着，该指针会被推入栈中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据。
  */

/** 堆栈性能区别：
 * 在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，
 * 只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，
 * 接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 
 * 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。
 */

/** 所有权规则：
 * 1、Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
 * 2、一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
 * 3、当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)
 */

 pub fn ownership_v1() {
    let a = 3;
    {
        let v = 32;
        println!("{},{}", a,v);
    }
    // println!("{}", v); // 超出作用域
 }



/** 转移所有权
 * 在rust中，对于分配在栈上的资源，进行赋值时执行的时copy操作，对于分配在堆上的资源，进行赋值时则会转移所有权。
 */
pub fn ownership_v2() {
    let a = 12;
    let b = a;
    println!("{}, {}", a, b);

    let content = String::from("abc");
    let c = content;

    // println!("{}, {}", content, c);  // 会报错，content已经转移了所有权，不能再使用了
}


/** Rust深拷贝和浅拷贝
 * 1、深拷贝：会拷贝堆里的信息，clone方法。
 * 2、浅拷贝：会拷贝栈里的信息，copy方法。
 * 
 * 浅拷贝只发生在栈上，因此性能很高；Rust 永远也不会自动创建数据的 “深拷贝”
 */
pub fn ownership_v3() {
    let i = 1; 
    let x = i;  // 发生了浅拷贝
    println!("{}, {}", i, x);

    let content = String::from("abc");
    let a = content.clone();

    println!("{}{}", content, a);
}

/** 函数传参所有权转移
 * 将值传递给函数，一样会发生 移动 或者 复制
 */
pub fn ownership_v4(){
    let a = String::from("abc");
    test(a);
    // println!("{}", a); // 报错，因为a的所有权已经转移到函数中了
}
pub fn test(s: String){
    println!("{}", s);
}