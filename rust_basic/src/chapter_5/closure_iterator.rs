/** 闭包是一种匿名函数，它可以赋值给变量也可以作为参数传递给其它函数，不同于函数的是，它允许捕获调用者作用域中的值
 *  闭包的三种fn特征：
 *      1、FnOnce：该类型的闭包会拿走被捕获变量的所有权，并且该闭包只能被运行一次。
 *      2、FnMut：它以可变借用的方式捕获环境中的值。
 *      3、Fn：它以不可变借用的方式捕获环境中的值。
 * 
 *  闭包三种fn特征的关系：
 *      1、所有的闭包都实现了FnOnce特征，也就是说任何闭包都至少可以被调用一次。
 *      2、没有移出所捕获变量的所有权的闭包自动实现了FnMut特征。
 *      3、不需要对捕获变量进行改变的闭包自动实现了Fn特征。
 */

fn test_1(){
    let a = |x: i32, y: i32| x + y;
    let _result = a(1,2);
}

// 方法中使用闭包
fn test_2<T>(add: T) -> i32 where T: Fn(i32, i32) -> i32 {
    add(1, 2)
} 

// 闭包作为函数的返回值
fn test_4() -> impl Fn(i32, i32) -> i32 {
    let m = 5;
    move |a, b| a + m + b
}

// 结构体中使用闭包
struct User<T> where T: Fn(i32) -> i32{
    query: T
}

/** 闭包获取上下文环境中的值
 * 当闭包从环境中捕获一个值时，会分配内存去存储这些值。对于有些场景来说，这种额外的内存分配会成为一种负担。
 */
fn test_3(){
    let a = String::from("abc");
    let _add = |x: &str| format!("{}-{}", a, x);   // 捕获上下文件环境中的a

    // 强制闭包取得被捕获变量的所有权
    let _sub = move |x: i32| format!("{}-{}", a, x);

    // println!("{}", a); // 这里会报错，因为a的所有权已经被转移了
}