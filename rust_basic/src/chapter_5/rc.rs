/** Rust 所有权机制要求一个值只能有一个所有者，在大多数情况下，都没有问题，但是考虑以下情况
 *      1、在图数据结构中，多个边可能会拥有同一个节点，该节点直到没有边指向它时，才应该被释放清理
 *      2、在多线程中，多个线程可能会持有同一个数据，但是你受限于 Rust 的安全机制，无法同时获取该数据的可变引用
 * 以上场景不是很常见，但是一旦遇到，就非常棘手，为了解决此类问题，Rust 在所有权机制之外又引入了额外的措施来简化相应的实现：通过引用计数的方式，允许一个数据资源在同一时刻拥有多个所有者。
 * 这种实现机制就是 Rc 和 Arc，前者适用于单线程，后者适用于多线程。
 */

/** Rc<T>
 *  引用计数(reference counting)，顾名思义，通过记录一个数据被引用的次数来确定该数据是否正在被使用。当引用次数归零时，就代表该数据不再被使用，因此可以被清理释放。
 *  Rc允许一个值有多个所有者，但是只能通过不可变引用来访问该值。Rc适用于单线程场景，如果需要在多线程中共享数据，则需要使用Arc。
 */

 use std::{rc::Rc, sync::Arc, thread};
fn test_1(){
    // 事实上，Rc<T> 是指向底层数据的不可变的引用，因此你无法通过它来修改数据，这也符合 Rust 的借用规则：要么存在多个不可变借用，要么只能存在一个可变借用。
    let a = String::from("abc");
    let x = Rc::new(a);     // 在这里a的所有权已经被拿走了
    let _y = x.clone();     // 这里x的所有权被克隆了一份，引用计数+1，仅仅复制了智能指针并增加了引用计数，并没有克隆底层数据
}



// Arc<T>：原子化的 Rc<T> 智能指针
fn test_2(){
    // 在将Rc用于多线程时，会报错，因为Rc是线程不安全的
    // let a = Rc::new("abc");
    // for _ in 0..10 {
    //     let temp = a.clone();
    //     thread::spawn(move || {
    //         println!("{}", temp);
    //     });
    // }
    let s = Arc::new("abc");
    for _ in 0..10 {
        let temp = s.clone();
        thread::spawn(move || {
            println!("{}", temp);
        });
    }
}